# 풀이
5자리 비트의 개수는 00000 ~ 01111 과 10000 ~ 10111 까지의 개수라고 할 수 있다.   
11000 ~ 11111 은 무조건 안되기 때문에 신경쓸 필요가 없다.   
따라서 위 경우는 f[5] = f[4] + f[3] 이 된다.    
이 것을 활용하여 전부 미리 답을 다 구해놓을 수 있다.   
하지만 주어진 값의 비트가 딱 떨어지지 않기 때문에 우리는 하나하나 구해줘야한다.   
예를 들어 10010110 의 8 자리 비트인 경우   
00000000 ~ 011111111 인 7자리 f(7)   
10000000 ~ 100101111 인 4자리 f(4)      
10010000 ~ 100100011 인 2자리 f(2)   
10010100 ~ 100100101 인 1자리 f(1) 의 합이 된다   
1이 연속될 경우 어짜피 1이 붙어 있는 것 이전까지 구하고 (위에서 f(1)) 바로 반환한다.
1이 붙어 있지 않을 경우 마지막 경우 10000000 까지해서 1을 더해서 반환한다.    
```c++
class Solution {
public: 
    int findIntegers(int num) {
        int f[32];
        
        f[0] = 1;
        f[1] = 2;
        
        for(int i=2;i<32;i++){
            f[i] = f[i-1] + f[i-2];
        }
        
        int result = 0;
        bool pre = false;
        for(int i=30;i>=0;i--){
            if(num & (1 << i)){
                result += f[i];
                if(pre) return result;
                pre = true;
            }else{
                pre = false;
            }
        }
        
        return result + 1;
    
    }
};
```